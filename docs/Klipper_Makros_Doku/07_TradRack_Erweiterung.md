## Makros in speziellen Erweiterungen (Beispiel: Annex **Trad**Rack)

Die **Annex Engineering TradRack** (manchmal fälschlich "Trad-Track" genannt) Mehrfach-Material-Einheit für Klipper ist ein Beispiel für ein erweitertes System, das intensiv von Makros Gebrauch macht. TradRack wird teils durch ein eigenes Klipper-Modul (Python-Seite) und teils durch Makros (Konfigurationsseite) gesteuert ([TradRack/docs/README.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/README.md#:~:text=Klipper.%20,that%20Trad%20Rack%20saves%20to)). In der TradRack-Dokumentation wird detailliert beschrieben, welche Makros und Variablen zur Anpassung dienen ([TradRack/docs/README.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/README.md#:~:text=%2A%20G,from%20the%20trad_rack%20klippy%20module)). 

So gibt es etwa ein Makro `[gcode_macro TR_Variables]`, in dem zahlreiche `variable_...` definiert sind, die Positionen, Geschwindigkeiten und Flags für das TradRack steuern ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=%60,these%20variables%20for%20more%20details)). Durch Ändern dieser Variablen oder deren Nutzung in anderen TradRack-Makros kann man das Verhalten (z.B. Filamentspitzen-Formung, Wipe-Positionen, etc.) anpassen. Ein anderes Makro `Shape_Tip` wird vor dem Filament-Unload aufgerufen, um die Filamentspitze vorzubereiten (rammen, cutten, etc.), und kann vom Nutzer angepasst oder ersetzt werden ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=%60,the%20slicer%2C%20filament%20cutting%2C%20etc)) ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=,macro)). Viele dieser TradRack-Makros nutzen ebenfalls Jinja2-Templates, um abhängig von Konfigurationsparametern unterschiedlichen Code auszuführen. 

TradRack demonstriert, wie Makros dazu benutzt werden können, komplexe Abläufe modular zu strukturieren: Das TradRack-Modul ruft definierte Makros an bestimmten Stellen auf (z.B. `Shape_Tip`, `Slicer_Unload`), der Nutzer kann diese Makros nach Bedarf anpassen, ohne ins Python-Modul eingreifen zu müssen ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=,macro)) ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=,shaping.%20See%20tip%20shaping)). Dabei gelten alle in dieser Übersicht genannten Mechanismen (Parameter, `printer`-Zugriffe auf TradRack-Status, etc.) genauso. Wer TradRack verwendet, sollte die offizielle Dokumentation konsultieren, um die spezifischen Makros und Variablen zu kennen ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=Macros)) ([TradRack/docs/kalico/Customization.md at main · Annex-Engineering/TradRack · GitHub](https://github.com/Annex-Engineering/TradRack/blob/main/docs/kalico/Customization.md#:~:text=macro,gcode_macro%20Set_Slicer_Unload_Preset)). Grundsätzlich sind keine speziellen Abweichungen vom üblichen Makro-System nötig – TradRack *erweitert* lediglich den verfügbaren `printer`-Status (z.B. `printer.trad_rack`) und definiert einige Makro-Vorlagen in mitgelieferten Beispielconfigs.
